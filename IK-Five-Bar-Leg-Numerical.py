import numpy as np
from scipy.optimize import root

# --- 1. ðŸ¤– à¸à¸³à¸«à¸™à¸”à¸žà¸²à¸£à¸²à¸¡à¸´à¹€à¸•à¸­à¸£à¹Œà¸„à¸‡à¸—à¸µà¹ˆà¸‚à¸­à¸‡à¸«à¸¸à¹ˆà¸™à¸¢à¸™à¸•à¹Œ (à¸«à¸™à¹ˆà¸§à¸¢ mm) ---
# (à¸­à¹‰à¸²à¸‡à¸­à¸´à¸‡à¸ˆà¸²à¸à¹€à¸­à¸à¸ªà¸²à¸£ fk.pdf à¸—à¸µà¹ˆà¹€à¸£à¸²à¸ªà¸£à¹‰à¸²à¸‡à¸‚à¸¶à¹‰à¸™)

# à¸žà¸´à¸à¸±à¸”à¸¡à¸­à¹€à¸•à¸­à¸£à¹Œ
P_A = np.array([-42.5, 0.0])  # à¸ˆà¸¸à¸” A (à¸¡à¸­à¹€à¸•à¸­à¸£à¹Œ 1, à¸‹à¹‰à¸²à¸¢)
P_B = np.array([42.5, 0.0])   # à¸ˆà¸¸à¸” B (à¸¡à¸­à¹€à¸•à¸­à¸£à¹Œ 2, à¸‚à¸§à¸²)

# à¸„à¸§à¸²à¸¡à¸¢à¸²à¸§à¸¥à¸´à¸‡à¸à¹Œ
L_AC = 105.0  # L1
L_BD = 105.0  # L2
L_CE = 145.0  # L3
L_DE = 145.0  # L4
L_EF = 40.0   # Offset

# à¸­à¸±à¸•à¸£à¸²à¸ªà¹ˆà¸§à¸™ Offset (à¸ˆà¸²à¸ PDF)
OFFSET_RATIO_E = 37.0 / 29.0  # (1 + 8/29)
OFFSET_RATIO_D = 8.0 / 29.0


# --- 2. âš™ï¸ à¸ªà¸£à¹‰à¸²à¸‡à¸Ÿà¸±à¸‡à¸à¹Œà¸Šà¸±à¸™ Forward Kinematics (FK) ---
# (à¸­à¹‰à¸²à¸‡à¸­à¸´à¸‡à¸ˆà¸²à¸ Section 2: Forward Kinematics (FK) Derivation)
# à¸Ÿà¸±à¸‡à¸à¹Œà¸Šà¸±à¸™à¸™à¸µà¹‰à¸ˆà¸°à¸„à¸³à¸™à¸§à¸“ P_F(x_f, y_f) à¸ˆà¸²à¸ [theta_A, theta_B]

def calculate_fk(thetas):
    """
    à¸„à¸³à¸™à¸§à¸“ Forward Kinematics (FK)
    Input: thetas = [theta_A, theta_B] (radians)
    Output: P_F = [x_f, y_f] (mm)
    """
    theta_A = thetas[0]
    theta_B = thetas[1]
    
    # 2.1) à¸„à¸³à¸™à¸§à¸“à¸žà¸´à¸à¸±à¸” "à¸‚à¹‰à¸­à¹€à¸‚à¹ˆà¸²" P_C à¹à¸¥à¸° P_D
    P_C = P_A + np.array([L_AC * np.cos(theta_A), L_AC * np.sin(theta_A)])
    P_D = P_B + np.array([L_BD * np.cos(theta_B), L_BD * np.sin(theta_B)])

    # 2.2) à¸„à¸³à¸™à¸§à¸“à¸žà¸´à¸à¸±à¸” "à¸ˆà¸¸à¸”à¹à¸à¹‰à¸›à¸±à¸à¸«à¸²" P_E (à¸ˆà¸¸à¸”à¸•à¸±à¸”à¸§à¸‡à¸à¸¥à¸¡ 2 à¸§à¸‡)
    # à¸™à¸µà¹ˆà¸„à¸·à¸­à¸‚à¸±à¹‰à¸™à¸•à¸­à¸™à¸—à¸µà¹ˆà¸‹à¸±à¸šà¸‹à¹‰à¸­à¸™ (Circle-Circle Intersection)
    V_CD = P_D - P_C
    d = np.linalg.norm(V_CD)
    
    # à¸›à¹‰à¸­à¸‡à¸à¸±à¸™à¸à¸²à¸£à¸«à¸²à¸£à¸”à¹‰à¸§à¸¢à¸¨à¸¹à¸™à¸¢à¹Œ à¸«à¸£à¸·à¸­à¸„à¹ˆà¸²à¸—à¸µà¹ˆà¹„à¸›à¹„à¸¡à¹ˆà¸–à¸¶à¸‡
    if d > (L_CE + L_DE) or d < abs(L_CE - L_DE) or d == 0:
        return np.array([np.nan, np.nan]) # à¸­à¸¢à¸¹à¹ˆà¸™à¸­à¸ Workspace

    a = (L_CE**2 - L_DE**2 + d**2) / (2 * d)
    h_squared = L_CE**2 - a**2
    if h_squared < 0:
        return np.array([np.nan, np.nan]) # à¸›à¹‰à¸­à¸‡à¸à¸±à¸™à¸„à¹ˆà¸²à¸•à¸´à¸”à¸¥à¸šà¸ˆà¸²à¸ floating point error
        
    h = np.sqrt(h_squared)
    
    v_d = V_CD / d               # à¹€à¸§à¸à¹€à¸•à¸­à¸£à¹Œà¸«à¸™à¸¶à¹ˆà¸‡à¸«à¸™à¹ˆà¸§à¸¢ C -> D
    v_perp = np.array([-v_d[1], v_d[0]]) # à¹€à¸§à¸à¹€à¸•à¸­à¸£à¹Œà¸•à¸±à¹‰à¸‡à¸‰à¸²à¸

    # à¹€à¸£à¸²à¸•à¹‰à¸­à¸‡à¹€à¸¥à¸·à¸­à¸ 1 à¹ƒà¸™ 2 à¸„à¸³à¸•à¸­à¸š (à¸ˆà¸¸à¸”à¸•à¸±à¸”à¸¡à¸µ 2 à¸ˆà¸¸à¸”)
    # à¹€à¸£à¸²à¸ˆà¸°à¹€à¸¥à¸·à¸­à¸à¸—à¹ˆà¸² "à¹€à¸‚à¹ˆà¸²à¸Šà¸µà¹‰à¸¥à¸‡" (y_e à¸¡à¸µà¸„à¹ˆà¸²à¸™à¹‰à¸­à¸¢à¸à¸§à¹ˆà¸²)
    # à¹‚à¸”à¸¢à¸—à¸±à¹ˆà¸§à¹„à¸›à¸„à¸·à¸­à¸à¸²à¸£à¹€à¸¥à¸·à¸­à¸à¹€à¸„à¸£à¸·à¹ˆà¸­à¸‡à¸«à¸¡à¸²à¸¢ +/-
    # à¹€à¸£à¸²à¸ˆà¸°à¹€à¸¥à¸·à¸­à¸ P_E = P_C + a*v_d - h*v_perp
    P_E = P_C + a * v_d - h * v_perp

    # 2.3) à¸„à¸³à¸™à¸§à¸“à¸žà¸´à¸à¸±à¸” "à¸›à¸¥à¸²à¸¢à¹€à¸—à¹‰à¸²" P_F (à¸ˆà¸²à¸ PDF)
    P_F = (OFFSET_RATIO_E * P_E) - (OFFSET_RATIO_D * P_D)
    
    return P_F

# --- 3. ðŸ“ à¸ªà¸£à¹‰à¸²à¸‡à¸Ÿà¸±à¸‡à¸à¹Œà¸Šà¸±à¸™ Jacobian (J_F) ---
# (à¸­à¹‰à¸²à¸‡à¸­à¸´à¸‡à¸ˆà¸²à¸ Section 3: Jacobian (JF) Derivation)
# à¸Ÿà¸±à¸‡à¸à¹Œà¸Šà¸±à¸™à¸™à¸µà¹‰à¸ˆà¸°à¸„à¸³à¸™à¸§à¸“ J_F(2x2) à¸ˆà¸²à¸ [theta_A, theta_B]

def calculate_jacobian(thetas):
    """
    à¸„à¸³à¸™à¸§à¸“ Jacobian Matrix (J_F)
    Input: thetas = [theta_A, theta_B] (radians)
    Output: J_F = 2x2 numpy array
    """
    theta_A = thetas[0]
    theta_B = thetas[1]

    # --- 3.1) à¸„à¸³à¸™à¸§à¸“à¸„à¹ˆà¸²à¸à¸¥à¸²à¸‡ (à¸ˆà¸³à¹€à¸›à¹‡à¸™à¸•à¹‰à¸­à¸‡à¹ƒà¸Šà¹‰ P_C, P_D, P_E) ---
    # (à¸£à¸±à¸™ FK à¸ªà¹ˆà¸§à¸™à¸«à¸™à¸¶à¹ˆà¸‡à¸‹à¹‰à¸³à¹€à¸žà¸·à¹ˆà¸­à¸«à¸²à¸„à¹ˆà¸² x_c, y_c, x_d, y_d, x_e, y_e)
    P_C = P_A + np.array([L_AC * np.cos(theta_A), L_AC * np.sin(theta_A)])
    P_D = P_B + np.array([L_BD * np.cos(theta_B), L_BD * np.sin(theta_B)])
    
    V_CD = P_D - P_C
    d = np.linalg.norm(V_CD)
    if d > (L_CE + L_DE) or d < abs(L_CE - L_DE) or d == 0:
        return np.empty((2,2)) * np.nan # à¸—à¸µà¹ˆà¸ˆà¸¸à¸” Singularity
        
    a = (L_CE**2 - L_DE**2 + d**2) / (2 * d)
    h_squared = L_CE**2 - a**2
    if h_squared < 0:
        return np.empty((2,2)) * np.nan
        
    h = np.sqrt(h_squared)
    v_d = V_CD / d
    v_perp = np.array([-v_d[1], v_d[0]])
    P_E = P_C + a * v_d - h * v_perp
    
    # à¹à¸¢à¸à¸•à¸±à¸§à¹à¸›à¸£à¹€à¸žà¸·à¹ˆà¸­à¸‡à¹ˆà¸²à¸¢à¸•à¹ˆà¸­à¸à¸²à¸£à¸­à¹ˆà¸²à¸™
    (x_c, y_c) = P_C
    (x_d, y_d) = P_D
    (x_e, y_e) = P_E

    # --- 3.2) à¸„à¸³à¸™à¸§à¸“ J_D (à¸ˆà¸²à¸ PDF 3.2) ---
    J_D = np.array([
        [0.0, -L_BD * np.sin(theta_B)],
        [0.0,  L_BD * np.cos(theta_B)]
    ])

    # --- 3.3) à¸„à¸³à¸™à¸§à¸“ J_E (à¸ˆà¸²à¸ PDF 3.3) ---
    # J_E = A_inv * B
    
    # à¸ªà¸£à¹‰à¸²à¸‡à¹€à¸¡à¸—à¸£à¸´à¸à¸‹à¹Œ A
    A = np.array([
        [x_e - x_c, y_e - y_c],
        [x_e - x_d, y_e - y_d]
    ])
    
    # à¸„à¸³à¸™à¸§à¸“ B_11 à¹à¸¥à¸° B_22
    B_11 = L_AC * ((y_e - y_c) * np.cos(theta_A) - (x_e - x_c) * np.sin(theta_A))
    B_22 = L_BD * ((y_e - y_d) * np.cos(theta_B) - (x_e - x_d) * np.sin(theta_B))
    
    # à¸ªà¸£à¹‰à¸²à¸‡à¹€à¸¡à¸—à¸£à¸´à¸à¸‹à¹Œ B
    B = np.array([
        [B_11, 0.0],
        [0.0,  B_22]
    ])
    
    # à¸„à¸³à¸™à¸§à¸“ J_E
    try:
        A_inv = np.linalg.inv(A)
        J_E = A_inv @ B
    except np.linalg.LinAlgError:
        # à¸™à¸µà¹ˆà¸„à¸·à¸­à¸ˆà¸¸à¸” Singularity (à¹€à¸Šà¹ˆà¸™ à¸‚à¸²à¹€à¸«à¸¢à¸µà¸¢à¸”à¸•à¸£à¸‡)
        return np.empty((2,2)) * np.nan

    # --- 3.4) à¸„à¸³à¸™à¸§à¸“ J_F (à¸ˆà¸²à¸ PDF 3.4) ---
    J_F = (1.0 / 29.0) * (37.0 * J_E - 8.0 * J_D)
    
    return J_F

# --- 4. ðŸŽ¯ à¸ªà¸£à¹‰à¸²à¸‡à¸Ÿà¸±à¸‡à¸à¹Œà¸Šà¸±à¸™à¸ªà¸³à¸«à¸£à¸±à¸š Solver ---
# Solver à¸•à¹‰à¸­à¸‡à¸à¸²à¸£ 2 à¸­à¸¢à¹ˆà¸²à¸‡:
# 1. à¸Ÿà¸±à¸‡à¸à¹Œà¸Šà¸±à¸™à¸—à¸µà¹ˆà¸„à¸·à¸™à¸„à¹ˆà¸² "Error" (Target - Current)
# 2. à¸Ÿà¸±à¸‡à¸à¹Œà¸Šà¸±à¸™à¸—à¸µà¹ˆà¸„à¸·à¸™à¸„à¹ˆà¸² "Jacobian" à¸‚à¸­à¸‡ Error (à¸‹à¸¶à¹ˆà¸‡à¸à¹‡à¸„à¸·à¸­ J_F à¸‚à¸­à¸‡à¹€à¸£à¸²)

def error_function(thetas, target_pose):
    """
    à¸„à¸³à¸™à¸§à¸“ Error = FK(thetas) - Target
    Solver à¸ˆà¸°à¸žà¸¢à¸²à¸¢à¸²à¸¡à¸—à¸³à¹ƒà¸«à¹‰à¸Ÿà¸±à¸‡à¸à¹Œà¸Šà¸±à¸™à¸™à¸µà¹‰à¸„à¸·à¸™à¸„à¹ˆà¸² [0, 0]
    """
    current_pose = calculate_fk(thetas)
    if np.isnan(current_pose).any():
        return np.array([1e6, 1e6]) # à¸„à¸·à¸™à¸„à¹ˆà¸² Error à¸¡à¸«à¸²à¸¨à¸²à¸¥à¸–à¹‰à¸²à¸­à¸­à¸à¸™à¸­à¸ Workspace
        
    error = current_pose - target_pose
    return error

def jacobian_for_solver(thetas, target_pose):
    """
    à¸„à¸·à¸™à¸„à¹ˆà¸² Jacobian à¸‚à¸­à¸‡ error_function
    (à¹€à¸™à¸·à¹ˆà¸­à¸‡à¸ˆà¸²à¸ target_pose à¹€à¸›à¹‡à¸™à¸„à¹ˆà¸²à¸„à¸‡à¸—à¸µà¹ˆ, jac(Error) à¸à¹‡à¸„à¸·à¸­ jac(FK) à¸«à¸£à¸·à¸­ J_F)
    """
    J_F = calculate_jacobian(thetas)
    if np.isnan(J_F).any():
        # à¸–à¹‰à¸² Jacobian à¸«à¸²à¸„à¹ˆà¸²à¹„à¸¡à¹ˆà¹„à¸”à¹‰ (Singularity) à¹ƒà¸«à¹‰ Solver à¹ƒà¸Šà¹‰à¸§à¸´à¸˜à¸µà¸›à¸£à¸°à¸¡à¸²à¸“à¸„à¹ˆà¸²à¹à¸—à¸™
        return None 
    return J_F

# --- 5. ðŸš€ à¸£à¸±à¸™ Solver à¹€à¸žà¸·à¹ˆà¸­à¸«à¸² IK ---
print("--- ðŸ¤– à¹€à¸£à¸´à¹ˆà¸¡à¸à¸²à¸£à¸„à¸³à¸™à¸§à¸“ Inverse Kinematics (Phase 1.2) ---")

# 5.1) à¸à¸³à¸«à¸™à¸”à¹€à¸›à¹‰à¸²à¸«à¸¡à¸²à¸¢ (Home Pose)
P_F_TARGET = np.array([0.0, -200.0])

# 5.2) à¸à¸³à¸«à¸™à¸”à¸„à¹ˆà¸² "à¹€à¸”à¸²" à¹€à¸£à¸´à¹ˆà¸¡à¸•à¹‰à¸™ (à¸ªà¸³à¸„à¸±à¸à¸¡à¸²à¸!)
# à¹€à¸£à¸²à¸•à¹‰à¸­à¸‡à¹€à¸”à¸²à¸„à¹ˆà¸²à¸¡à¸¸à¸¡à¹€à¸£à¸´à¹ˆà¸¡à¸•à¹‰à¸™ (à¹€à¸›à¹‡à¸™ radians)
# à¸–à¹‰à¸²à¹€à¸”à¸²à¹„à¸¡à¹ˆà¸”à¸µ Solver à¸­à¸²à¸ˆà¸«à¸²à¹„à¸¡à¹ˆà¹€à¸ˆà¸­ à¸«à¸£à¸·à¸­à¸«à¸²à¸—à¹ˆà¸²à¸œà¸´à¸”
# à¸—à¹ˆà¸²à¸—à¸µà¹ˆà¸•à¹‰à¸­à¸‡à¸à¸²à¸£: à¸—à¸±à¹‰à¸‡à¸ªà¸­à¸‡à¹à¸‚à¸™à¸Šà¸µà¹‰à¸¥à¸‡ (M1 â‰ˆ -135Â°, M2 â‰ˆ -45Â°)
initial_guess = np.deg2rad([-135.0, -45.0])

print(f"ðŸŽ¯ à¹€à¸›à¹‰à¸²à¸«à¸¡à¸²à¸¢ (Target Pose): {P_F_TARGET} mm")
print(f"ðŸ¤” à¸„à¹ˆà¸²à¹€à¸”à¸²à¹€à¸£à¸´à¹ˆà¸¡à¸•à¹‰à¸™: {np.rad2deg(initial_guess)} à¸­à¸‡à¸¨à¸²")

# 5.3) à¹€à¸£à¸µà¸¢à¸à¹ƒà¸Šà¹‰ Scipy Root Solver
# 'fun': à¸Ÿà¸±à¸‡à¸à¹Œà¸Šà¸±à¸™ Error à¸—à¸µà¹ˆà¹€à¸£à¸²à¸•à¹‰à¸­à¸‡à¸à¸²à¸£à¹ƒà¸«à¹‰à¹€à¸›à¹‡à¸™à¸¨à¸¹à¸™à¸¢à¹Œ
# 'x0': à¸„à¹ˆà¸²à¹€à¸”à¸²à¹€à¸£à¸´à¹ˆà¸¡à¸•à¹‰à¸™
# 'args': à¸žà¸²à¸£à¸²à¸¡à¸´à¹€à¸•à¸­à¸£à¹Œà¸­à¸·à¹ˆà¸™à¹† à¸—à¸µà¹ˆà¸ˆà¸°à¸ªà¹ˆà¸‡à¹ƒà¸«à¹‰ 'fun' (à¹ƒà¸™à¸—à¸µà¹ˆà¸™à¸µà¹‰à¸„à¸·à¸­ P_F_TARGET)
# 'jac': à¸Ÿà¸±à¸‡à¸à¹Œà¸Šà¸±à¸™ Jacobian à¸—à¸µà¹ˆà¹€à¸£à¸² derive à¹„à¸§à¹‰ (à¸Šà¹ˆà¸§à¸¢à¹ƒà¸«à¹‰ Solver à¸—à¸³à¸‡à¸²à¸™à¹€à¸£à¹‡à¸§à¹à¸¥à¸°à¹à¸¡à¹ˆà¸™à¸¢à¸³)
# 'method': 'hybr' à¹€à¸›à¹‡à¸™ method à¸—à¸µà¹ˆà¸”à¸µà¸ªà¸³à¸«à¸£à¸±à¸šà¸›à¸±à¸à¸«à¸²à¸™à¸µà¹‰
sol = root(
    fun=error_function,
    x0=initial_guess,
    args=(P_F_TARGET,),
    jac=jacobian_for_solver, # <--- à¹€à¸£à¸²à¹ƒà¸Šà¹‰ J_F à¸—à¸µà¹ˆà¹€à¸£à¸² derive à¸¡à¸²à¸•à¸£à¸‡à¸™à¸µà¹‰!
    method='hybr' 
)

# --- 6. ðŸ“Š à¸ªà¸£à¸¸à¸›à¸œà¸¥à¸¥à¸±à¸žà¸˜à¹Œ ---
print("\n--- âœ… à¸œà¸¥à¸¥à¸±à¸žà¸˜à¹Œà¸à¸²à¸£à¸„à¸³à¸™à¸§à¸“ IK ---")
if sol.success:
    solution_angles_rad = sol.x
    solution_angles_deg = np.rad2deg(solution_angles_rad)
    
    # à¸›à¸£à¸±à¸šà¸¡à¸¸à¸¡à¹ƒà¸«à¹‰à¹€à¸‚à¹‰à¸²à¸Šà¹ˆà¸§à¸‡ Â±180 à¸­à¸‡à¸¨à¸²
    solution_angles_deg_normalized = ((solution_angles_deg + 180) % 360) - 180
    
    print(f"ðŸ”¥ Solver à¸žà¸šà¸„à¸³à¸•à¸­à¸š!")
    print(f"   Theta A (M1): {solution_angles_deg[0]:.4f} à¸­à¸‡à¸¨à¸² â†’ à¸›à¸£à¸±à¸šà¹€à¸›à¹‡à¸™ {solution_angles_deg_normalized[0]:.4f} à¸­à¸‡à¸¨à¸²")
    print(f"   Theta B (M2): {solution_angles_deg[1]:.4f} à¸­à¸‡à¸¨à¸² â†’ à¸›à¸£à¸±à¸šà¹€à¸›à¹‡à¸™ {solution_angles_deg_normalized[1]:.4f} à¸­à¸‡à¸¨à¸²")
    
    # à¸•à¸£à¸§à¸ˆà¸ªà¸­à¸šà¸„à¸§à¸²à¸¡à¹à¸¡à¹ˆà¸™à¸¢à¸³:
    verification_pose = calculate_fk(solution_angles_rad)
    print("\n--- ðŸ” à¸à¸²à¸£à¸•à¸£à¸§à¸ˆà¸ªà¸­à¸šà¸œà¸¥à¸¥à¸±à¸žà¸˜à¹Œ (à¸™à¸³à¸¡à¸¸à¸¡à¸—à¸µà¹ˆà¹„à¸”à¹‰à¹„à¸›à¸£à¸±à¸™ FK) ---")
    print(f"   à¸žà¸´à¸à¸±à¸”à¸—à¸µà¹ˆà¹„à¸”à¹‰à¸ˆà¸²à¸à¸à¸²à¸£à¸„à¸³à¸™à¸§à¸“ FK: [{verification_pose[0]:.6f}, {verification_pose[1]:.6f}]")
    print(f"   à¹€à¸›à¹‰à¸²à¸«à¸¡à¸²à¸¢à¸—à¸µà¹ˆà¸•à¹‰à¸­à¸‡à¸à¸²à¸£:         [{P_F_TARGET[0]:.1f}, {P_F_TARGET[1]:.1f}]")
    print(f"   Error: {sol.fun}")
else:
    print(f"ðŸ˜¥ Solver à¹„à¸¡à¹ˆà¸ªà¸²à¸¡à¸²à¸£à¸–à¸«à¸²à¸„à¸³à¸•à¸­à¸šà¹„à¸”à¹‰ (sol.success = False)")
    print(f"   à¸‚à¹‰à¸­à¸„à¸§à¸²à¸¡à¸ˆà¸²à¸ Solver: {sol.message}")